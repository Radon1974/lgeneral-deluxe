/* Copyright (C) 2002 Christopher Clark <firstname.lastname@cl.cam.ac.uk> */

#ifndef __HASHTABLE_CWC22_H__
#define __HASHTABLE_CWC22_H__

struct hashtable;

/* Пример использования:
 *
 *      struct hashtable  *h;
 *      struct some_key   *k;
 *      struct some_value *v;
 *
 *      static unsigned int         hash_from_key_fn( void *k );
 *      static int                  keys_comp_fn ( void *key1, void *key2 );
 *
 *      h = create_hashtable(16, hash_from_key_fn, keys_equal_fn, 0);
 *      k = (struct some_key *)     malloc(sizeof(struct some_key));
 *      v = (struct some_value *)   malloc(sizeof(struct some_value));
 *
 *      (инициализировать k и v подходящими значениями)
 *
 *      if (! hashtable_insert(h,k,v) )
 *      {     exit(-1);               }
 *
 *      if (NULL == (found = hashtable_search(h,k) ))
 *      {    printf("not found!");                  }
 *
 *      if (NULL == (found = hashtable_remove(h,k) ))
 *      {    printf("Not found\n");                 }
 *
 */

/* Макросы могут использоваться для определения функций доступа к хэш-таблице с типобезопасностью (r), с
 * методы, специализирующиеся на использовании известных типов ключей и значений в качестве параметров.
 *
 * пример:
 *
 * Вставьте это в начало вашего файла:
 *
 * DEFINE_HASHTABLE_INSERT(insert_some, struct some_key, struct some_value);
 * DEFINE_HASHTABLE_SEARCH(search_some, struct some_key, struct some_value);
 * DEFINE_HASHTABLE_REMOVE(remove_some, struct some_key, struct some_value);
 *
 * Это определяет функции insert_some, search_some и remove_some.
 * Они работают так же, как hashtable_insert и т. Д., С теми же параметрами,
 * но их сигнатуры функций имеют 'struct some_key *', а не
 * 'void *' и, следовательно, может генерировать ошибки времени компиляции, если ваша программа
 * предоставление неверных данных в качестве ключа (и аналогично для значения).
 *
 * Обратите внимание, что функции хеширования и равенства ключей переданы в create_hashtable
 * по-прежнему принимает параметры 'void *' вместо 'some key *'. Этого не должно быть
 * сложный вопрос, так как они определены и пройдены только один раз, а другой
 * функции будут гарантировать, что им будут предоставлены только действительные ключи.
 *
 * Стоимость этой проверки - увеличенный размер кода и накладные расходы времени выполнения.
 * - если важна производительность, возможно, стоит вернуться к
 * небезопасные методы после того, как ваша программа была отлажена безопасными методами.
 * Для этого просто нужно переключиться на несколько простых альтернативных определений, например:
 * #define insert_some hashtable_insert
 *
 */

/*****************************************************************************
 * create_hashtable

 * @name                    create_hashtable
 * @param   minsize         минимальный начальный размер хеш-таблицы
 * @param   hashfunction    функция для ключей хеширования
 * @param   key_comp_fn     функция сравнения двух ключей (семантика strcmp)
 * @param   destroy_fn      функция для освобождения значения, если hashtable_destroy
 *                          вызывается с free = 1. Если не дано, бесплатно будет
 *                          называется.
 * @return                  вновь созданная хеш-таблица или NULL в случае ошибки
 */

struct hashtable *
create_hashtable(unsigned int minsize,
                 unsigned int (*hashfunction) (void*),
                 int (*key_comp_fn) (void*,void*),
		 void (*destroy_fn) (void *));

/*****************************************************************************
 * hashtable_insert

 * @name        hashtable_insert
 * @param   h   хеш-таблица для вставки в
 * @param   k   ключ - хеш-таблица претендует на владение и будет бесплатно удалена
 * @param   v   стоимость - не претендует на право собственности
 * @return      ненулевое значение для успешной вставки
 *
 * Эта функция приведет к расширению таблицы, если вставка займет
 * отношение количества записей к размеру таблицы сверх максимального коэффициента загрузки.
 *
 * Эта функция не проверяет повторные вставки с повторяющимся ключом.
 * Значение, возвращаемое при использовании повторяющегося ключа, не определено - когда
 * размер хеш-таблицы изменяется, порядок извлечения дубликата ключа
 * записи перевернуты.
 * В случае сомнений удалите перед вставкой.
 */

int
hashtable_insert(struct hashtable *h, void *k, void *v);

#define DEFINE_HASHTABLE_INSERT(fnname, keytype, valuetype) \
int fnname (struct hashtable *h, keytype *k, valuetype *v) \
{ \
    return hashtable_insert(h,k,v); \
}

/*****************************************************************************
 * hashtable_search

 * @name        hashtable_search
 * @param   h   хеш-таблица для поиска
 * @param   k   ключ для поиска - не претендует на право собственности
 * @return      значение, связанное с ключом, или NULL, если ничего не найдено
 */

void *
hashtable_search(struct hashtable *h, void *k);

#define DEFINE_HASHTABLE_SEARCH(fnname, keytype, valuetype) \
valuetype * fnname (struct hashtable *h, keytype *k) \
{ \
    return (valuetype *) (hashtable_search(h,k)); \
}

/*****************************************************************************
 * hashtable_remove

 * @name        hashtable_remove
 * @param   h   the hashtable to remove the item from
 * @param   k   the key to search for  - does not claim ownership
 * @return      the value associated with the key, or NULL if none found
 */

void * /* возвращает значение */
hashtable_remove(struct hashtable *h, void *k);

#define DEFINE_HASHTABLE_REMOVE(fnname, keytype, valuetype) \
valuetype * fnname (struct hashtable *h, keytype *k) \
{ \
    return (valuetype *) (hashtable_remove(h,k)); \
}


/*****************************************************************************
 * hashtable_count

 * @name        hashtable_count
 * @param   h   хеш-таблица
 * @return      количество элементов, хранящихся в хеш-таблице
 */
unsigned int
hashtable_count(struct hashtable *h);


/*****************************************************************************
 * hashtable_destroy

 * @name        hashtable_destroy
 * @param   h   хеш-таблица
 * @param       free_values, следует ли называть "свободными" оставшиеся значения
 */

void
hashtable_destroy(struct hashtable *h, int free_values);

#endif /* __HASHTABLE_CWC22_H__ */

/*
 * Авторское право (c) 2002, Кристофер Кларк
 * Все права защищены.
 *
 * Распространение и использование в исходной и двоичной формах, с или без
 * модификации, допускаются при соблюдении следующих условий
 * которые встретились:
 *
 * * При повторном распространении исходного кода должно сохраняться указанное выше авторское право.
 * обратите внимание, этот список условий и следующий отказ от ответственности.
 *
 * * Распространение в двоичной форме должно воспроизводить вышеуказанные авторские права.
 * обратите внимание, этот список условий и следующий отказ от ответственности в
 * документация и / или другие материалы, поставляемые с дистрибутивом.
 *
 * * Ни имени оригинального автора; ни имена участников
 * может использоваться для поддержки или продвижения продуктов, созданных на основе этого программного обеспечения.
 * без специального предварительного письменного разрешения.
 *
 *
 * ДАННОЕ ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ ВЛАДЕЛЬЦАМИ АВТОРСКИХ ПРАВ И СОСТАВЛЯМИ
 * "КАК ЕСТЬ" И ЛЮБЫЕ ЯВНЫЕ ИЛИ ПОДРАЗУМЕВАЕМЫЕ ГАРАНТИИ, ВКЛЮЧАЯ, НО НЕ
 * ОГРАНИЧИВАЕТСЯ ПОДРАЗУМЕВАЕМЫМИ ГАРАНТИЯМИ КОММЕРЧЕСКОЙ ЦЕННОСТИ И ПРИГОДНОСТИ ДЛЯ
 * ОТКАЗ ОТ КОНКРЕТНОЙ ЦЕЛИ. НИ В КОЕМ СЛУЧАЕ ВЛАДЕЛЕЦ АВТОРСКИМИ ПРАВАМИ
 * ИЛИ СОСТАВНИКИ НЕСЕТ ОТВЕТСТВЕННОСТЬ ЗА ЛЮБЫЕ ПРЯМЫЕ, КОСВЕННЫЕ, СЛУЧАЙНЫЕ, СПЕЦИАЛЬНЫЕ,
 * ОБЯЗАТЕЛЬНЫЕ ИЛИ КОСВЕННЫЕ УБЫТКИ (ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАясь,
 * ЗАКУПКА ТОВАРОВ ИЛИ УСЛУГ ЗАМЕНЫ; ПОТЕРЯ ИСПОЛЬЗОВАНИЯ, ДАННЫХ ИЛИ
 * ПРИБЫЛЬ; ИЛИ ПЕРЕРЫВ ДЕЯТЕЛЬНОСТИ), ОДНАКО ВЫЗВАННЫМ И НА ЛЮБОЙ ТЕОРИИ
 * ОТВЕТСТВЕННОСТЬ, ЛИБО ПО ДОГОВОРУ, СТРОГОЙ ОТВЕТСТВЕННОСТИ ИЛИ ПЕРЕДАЧИ (ВКЛЮЧАЯ
 * НЕБРЕЖНОСТЬ ИЛИ ИНАЧЕ), ВОЗНИКАЮЩИЕ ЛЮБОЙ СПОСОБОМ ИСПОЛЬЗОВАНИЯ ЭТОГО
 * ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ, ДАЖЕ ПРИ СООБЩЕНИИ О ВОЗМОЖНОСТИ ТАКОГО ПОВРЕЖДЕНИЯ.
*/
