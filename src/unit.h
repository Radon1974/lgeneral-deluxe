/***************************************************************************
                          unit.h  -  description
                             -------------------
    begin                : Fri Jan 19 2001
    copyright            : (C) 2001 by Michael Speck
    email                : kulkanie@gmx.net
 ***************************************************************************/
/***************************************************************************
                     Modifications by LGD team 2012+.
 ***************************************************************************/
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

#ifndef __UNIT_H
#define __UNIT_H

#include "unit_lib.h"
#include "nation.h"
#include "player.h"
#include "terrain.h"

//#define DEBUG_ATTACK

/*
====================================================================
Типы посадки для юнита.
====================================================================
*/
enum {
    EMBARK_NONE = 0,
    EMBARK_GROUND,
    EMBARK_SEA,
    EMBARK_AIR,
    DROP_BY_PARACHUTE
};

/*
====================================================================
Направление взгляда юнитов (используется как идентификатор значка).
====================================================================
*/
enum {
    UNIT_ORIENT_RIGHT = 0,
    UNIT_ORIENT_LEFT,
    UNIT_ORIENT_UP = 0,
    UNIT_ORIENT_RIGHT_UP,
    UNIT_ORIENT_RIGHT_DOWN,
    UNIT_ORIENT_DOWN,
    UNIT_ORIENT_LEFT_DOWN,
    UNIT_ORIENT_LEFT_UP
};

/* барабан жизни юнита */
/* используются не цвета, а растровые изображения с мелкими цветными плитками */
enum {
    BAR_WIDTH = 31,
    BAR_HEIGHT = 4,
    BAR_TILE_WIDTH = 3,
    BAR_TILE_HEIGHT = 4
};

/* основные и вспомогательные флаги */
enum{
    AUXILIARY = 0,
    CORE,
    STARTING_CORE
};

/*
====================================================================
Тактический юнит.
Мы разрешаем объединение юнитов, поэтому основные свойства могут измениться и
поэтому не указатели на библиотеку, а мелкие копии
(это означает, что идентификатор записи, имя, значки, звуки ЯВЛЯЮТСЯ указателями
и не тронут).
Чтобы определить, есть ли у юнита транспортёр unit-> trsp_prop-> id
проверено. (0 = нет транспортера, 1 = есть транспортер)
====================================================================
*/
typedef struct _Unit {
    Unit_Lib_Entry prop;        /* свойства */
    Unit_Lib_Entry trsp_prop;   /* свойства транспортеров */
    Unit_Lib_Entry land_trsp_prop; /* имущество наземных транспортеров (используется во время морских перевозок) */
    Unit_Lib_Entry *sel_prop;   /* выбранные реквизиты: либо prop, либо trsp_prop */
    struct _Unit *backup;       /* используется для резервного копирования различных значений единиц, которые могут временно изменяться (например, ожидаемые убытки) */
    char name[24];              /* название подразделения */
    Player *player;             /* контролирующий игрок */
    Nation *nation;             /* национальный юнит принадлежит */
    Terrain_Type *terrain;      /* местность, на которой в настоящее время находится юнит */
    int x, y;                   /* положение на карте */
    int str;                    /* сила */
    int max_str;                /* единица максимальной силы может заменить */
    int cur_str_repl;           /* силовая единица в настоящее время может заменить */
    int repl_exp_cost;          /* потеря опыта при замене */
    int repl_prestige_cost;     /* престиж для оплаты в случае замены */
    int entr;                   /* окоп */
    int exp;                    /* опыт */
    int exp_level;              /* уровень опыта вычисляется из опыта */
    int delay;                  /* задержка хода до того, как юнит станет доступным
                                   как подкрепление */
    int embark;                 /* тип посадки */
    int orient;                 /* текущая ориентация */
    int icon_offset;            /* смещение в единицах sel_prop->icon */
    int icon_tiny_offset;       /* смещение в sep_prop->tiny_icon */
    int supply_level;           /* в процентах; военные объекты являются центрами снабжения */
    int cur_fuel;               /* текущее топливо */
    int cur_ammo;               /* текущие боеприпасы */
    int cur_mov;                /* движение указывает этот ход */
    int cur_mov_saved;          /* сохраненное состояние точек движения для чит-кода "турбо-юниты" */
    int cur_atk_count;          /* количество атак в этот ход */
    int unused;                 /* отряд пока не предпринимал действий в этот ход */
    int damage_bar_width;       /* текущая ширина полосы жизни в map->life_icons */
    int damage_bar_offset;      /* смещение в map->damage_icons */
    int suppr;                  /* подавление юнита за одиночный бой
                                   (вызвано артиллерией, очищено после боя) */
    int turn_suppr;             /* подавление юнита на весь оборот
                                   вызвано тактической бомбардировкой, низким уровнем топлива (<20) или
                                   низкий боезапас (<2) */
    int is_guarding;            /* не включайте в список при езде на велосипеде юнита */
    int killed;                 /* 1: удалить с карты и удалить этот блок
                                   2: удалить только с карты
                                   3: удалить только */
    int fresh_deploy;           /* если это правда то это подразделение было развернуто в этом повороте
                                   и пока он не используется он может быть не развернут в тот
                                    же ход */
    char tag[32];               /* если тег установлен то юнит принадлежит к группе юнитов которая
                                    контролируется условиями победы units_killed()
                                   и units_saved() */
    int core;                   /* 1: Основной юнит
                                   2: Вспомогательный юнит */
    int eval_score;             /* от 0 до 1000, указывающих на стоимость юнита */
    /* ИИ оценка */
    int target_score;           /* когда цели блока ИИ собираются это значение устанавливается
                                   к результату начисляется балл за атаку подразделения по данной цели */
    char star[6][20];           /* содержит информацию о боевых почестях */
} __attribute((packed)) Unit;

/*
====================================================================
Создайте блок, передав структуру блока со следующим набором элементов:
  х, г, ул. Пятницкая, опыта, задержки, Ориент, нации, плеер.
Эта функция будет использовать переданные значения для создания единичной структуры
со всеми заданными тогда значениями.
====================================================================
*/
Unit *unit_create( Unit_Lib_Entry *prop, Unit_Lib_Entry *trsp_prop,
                   Unit_Lib_Entry *land_trsp_prop, Unit *base );

/*
====================================================================
Удалить единицу. Передайте указатель как void*, чтобы разрешить использование в качестве
обратного вызова для списка.
====================================================================
*/
void unit_delete( void *ptr );

/*
====================================================================
Дайте единице общее название.
====================================================================
*/
void unit_set_generic_name( Unit *unit, int number, const char *stem );

/*
====================================================================
Обновите значок устройства в соответствии с его ориентацией.
====================================================================
*/
void unit_adjust_icon( Unit *unit );

/*
====================================================================
Отрегулируйте ориентацию (и отрегулируйте значок) устройства, если вы смотрите в направлении x, y.
====================================================================
*/
void unit_adjust_orient( Unit *unit, int x, int y );

/*
====================================================================
Проверьте, может ли подразделение что-то поставить (боеприпасы, топливо, что угодно), и
верните количество, которое можно поставить.
====================================================================
*/
enum {
    UNIT_SUPPLY_AMMO = 1,
    UNIT_SUPPLY_FUEL,
    UNIT_SUPPLY_ANYTHING,
    UNIT_SUPPLY_ALL
};
int unit_check_supply( Unit *unit, int type, int *missing_ammo, int *missing_fuel );

/*
====================================================================
Процент подачи максимального количества топлива/боеприпасов/и того, и другого
Верните True, если единица измерения была поставлена.
====================================================================
*/
int unit_supply_intern( Unit *unit, int type );
int unit_supply( Unit *unit, int type );

/*
====================================================================
Проверьте, использует ли юнит топливо в своем текущем состоянии (загружено или нет).
====================================================================
*/
int unit_check_fuel_usage( Unit *unit );

/*
====================================================================
Добавьте опыт и вычислите уровень опыта.
Верните True, если уровень повышен.
====================================================================
*/
int unit_add_exp( Unit *unit, int exp );

/*
====================================================================
Установить / размонтировать юнит на наземном транспортере.
====================================================================
*/
void unit_mount( Unit *unit );
void unit_unmount( Unit *unit );

/*
====================================================================
Проверьте, находятся ли блоки близко друг к другу. Это значит на соседних
шестигранные плитки.
====================================================================
*/
int unit_is_close( Unit *unit, Unit *target );

/*
====================================================================
Проверить, может ли юнит активно атаковать (атака, инициированная отрядом) или
пассивная атака (атака по инициированной цели, защита юнита) цель.
====================================================================
*/
enum {
    UNIT_ACTIVE_ATTACK = 0,
    UNIT_PASSIVE_ATTACK,
    UNIT_DEFENSIVE_ATTACK
};
int unit_check_attack( Unit *unit, Unit *target, int type );

/*
====================================================================
Вычислить урон / подавление, которое получает цель при атаке юнита
цель. Никакие свойства не будут изменены. Если установлено значение "реальный"
кости брошены, иначе это стохастический прогноз.
====================================================================
*/
void unit_get_damage( Unit *aggressor, Unit *unit, Unit *target,
                      int type,
                      int real, int rugged_def,
                      int *damage, int *suppr );

/*
====================================================================
Проведите одиночный бой (без проверки оборонительного огня) со случайными значениями.
unit_surprise_attack () обрабатывает атаку с неожиданной целью
(например, Out Of The Sun)
Если в обычном бою возникла надежная защита (неожиданная_атака равна
всегда прочный) 'rugged_def' установлен.
Уменьшается боезапас и набирается опыт.
unit_normal_attack () принимает UNIT_ACTIVE_ATTACK или
UNIT_DEFENSIVE_ATTACK как «тип» в зависимости от того, поддерживает ли это устройство
или активно атакует.
====================================================================
*/
enum {
    AR_NONE                  = 0,            /* ничего особенного */
    AR_UNIT_ATTACK_BROKEN_UP = ( 1L << 1),   /* удар по цели первым и атака отряда */
    AR_UNIT_SUPPRESSED       = ( 1L << 2),   /* юнит жив, но полностью подавлен */
    AR_TARGET_SUPPRESSED     = ( 1L << 3),   /* вот */
    AR_UNIT_KILLED           = ( 1L << 4),   /* реальная сила 0 */
    AR_TARGET_KILLED         = ( 1L << 5),   /* вот */
    AR_RUGGED_DEFENSE        = ( 1L << 6),   /* цель сделана надежной защитой */
    AR_EVADED                = ( 1L << 7),   /* юнит уклонился */
};
int unit_normal_attack( Unit *unit, Unit *target, int type );
int unit_surprise_attack( Unit *unit, Unit *target );

/*
====================================================================
Пройдите полную боевой юнит против цели, включая известные (!)
защитные средства поддержки и без случайных модификаций.
Вернуть окончательный урон, полученный обоими юнитами.
Поскольку местность может влиять на идентификатор местности, битва
имеет место (гекс защищающегося отряда).
====================================================================
*/
void unit_get_expected_losses( Unit *unit, Unit *target, int *unit_damage, int *target_damage );

/*
====================================================================
Эта функция проверяет «юнит» на наличие сторонников «цели».
что даст оборонительный огонь перед настоящим сражением
«юнит» против «цели» имеет место. Эти единицы помещаются в 'df_units'
(который здесь не создается)
====================================================================
*/
void unit_get_df_units( Unit *unit, Unit *target, List *units, List *df_units );

/*
====================================================================
Проверьте, можно ли заменить устройство. Тип ЗАМЕНА или
ELITE_REPLACEMENTS.
====================================================================
*/
enum {
    REPLACEMENTS = 0,
    ELITE_REPLACEMENTS
};
int unit_check_replacements( Unit *unit, int type );

/*
====================================================================
Получайте единицы силы за счет замены. Тип
ЗАМЕНА или ELITE_REPLACEMENTS.
====================================================================
*/
int unit_get_replacement_strength( Unit *unit, int type );

/*
====================================================================
Получите замену для юнита. Тип ЗАМЕНА или
ELITE_REPLACEMENTS.
====================================================================
*/
void unit_replace( Unit *unit, int type );

/*
====================================================================
Проверьте, разрешено ли этим двум юнитам сливаться друг с другом.
====================================================================
*/
int unit_check_merge( Unit *unit, Unit *source );

/*
====================================================================
Получите максимальную силу, которую отряд может дать, разделив его
Текущее состояние. У отряда должно быть не менее 3 оставшихся сил.
====================================================================
*/
int unit_get_split_strength( Unit *unit );

/*
====================================================================
Объедините эти два юнита: юнит - это новый модуль, а источник должен быть
удаляется с карты и памяти после вызова этой функции.
====================================================================
*/
void unit_merge( Unit *unit, Unit *source );

/*
====================================================================
Верните True, если юнит использует наземный транспортер.
====================================================================
*/
int unit_check_ground_trsp( Unit *unit );

/*
====================================================================
Резервное копирование на указатель резервного копирования (неглубокая копия)
====================================================================
*/
void unit_backup( Unit *unit );
void unit_restore( Unit *unit );

/*
====================================================================
Проверьте, может ли цель обеспечить надежную защиту
====================================================================
*/
int unit_check_rugged_def( Unit *unit, Unit *target );

/*
====================================================================
Вычислите шанс надежной защиты.
====================================================================
*/
int unit_get_rugged_def_chance( Unit *unit, Unit *target );

/*
====================================================================
Рассчитайте количество использованного топлива. "стоимость" - это базовая стоимость топлива, которая должна быть
вычитается за счет движения по местности. Стоимость будет корректироваться по мере необходимости.
====================================================================
*/
int unit_calc_fuel_usage( Unit *unit, int cost );

/*
====================================================================
Обновить панель юнита.
====================================================================
*/
void unit_update_bar( Unit *unit );

/*
====================================================================
Отключить все действия.
====================================================================
*/
void unit_set_as_used( Unit *unit );

/*
====================================================================
Дублируйте объект, создав новое имя (для разделения) или без
новое имя (для информации о перезапуске кампании).
====================================================================
*/
Unit *unit_duplicate( Unit *unit, int generate_new_name );

/*
====================================================================
Проверьте, есть ли у юнита мало боеприпасов или топлива.
====================================================================
*/
int unit_low_fuel( Unit *unit );
int unit_low_ammo( Unit *unit );

/*
====================================================================
Проверьте, можно ли рассматривать юнит для развертывания.
====================================================================
*/
int unit_supports_deploy( Unit *unit );

/*
====================================================================
Сбрасывает атрибуты юнита (подготовить юниту к следующему сценарию).
====================================================================
*/
void unit_reset_attributes( Unit *unit );

#endif
