/***************************************************************************
                          parser.h  -  description
                             -------------------
    begin                : Sat Mar 9 2002
    copyright            : (C) 2001 by Michael Speck
    email                : kulkanie@gmx.net
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/


#ifndef __PARSER_H
#define __PARSER_H

#include "list.h"
#include <stdio.h>

struct CommonTreeData;

/*
====================================================================
Этот модуль предоставляет функции для анализа данных ASCII из строк.
и файлы.
Синопсис:
  имя группы <начальная группа> запись1 .. записьX <конечная группа>
  переменная <set> значение
Запись группы может быть переменной или группой (чередование).
Значение переменной может быть либо отдельным токеном, либо списком токенов.
заключен в <начальный список> <конечный список>.
Текст, заключенный в "..", считается одним токеном.
====================================================================
*/

/*
====================================================================
Символы.
Примечание. Эти символы игнорируются, если они находятся в токене «<выражение>».
поскольку они тогда принадлежат этому токену.
PARSER_GROUP_BEGIN:   <начать группу>
PARSER_GROUP_END:     <конечная группа>
PARSER_SET:           <набор>
PARSER_LIST_BEGIN:    <начать список>
PARSER_LIST_END:      <конец списка>
PARSER_COMMENT_BEGIN: <начать комментарий>
PARSER_COMMENT_END:   <конец комментария>
PARSER_STRING:        <строка>
PARSER_SYMBOLS:       Список всех символов + пробел, используемых для
                      разделить строки и токены.
PARSER_SKIP_SYMBOLS:  текст между этими двумя символами обрабатывается как
                      комментарий и поэтому полностью игнорируется
====================================================================
*/
typedef enum ParserToken {
  PARSER_INVALID =       -2,
  PARSER_EOI =           -1,
  PARSER_GROUP_BEGIN =   '{',
  PARSER_GROUP_END =     '}',
  PARSER_SET =           '=',
  PARSER_LIST_BEGIN =    '(',
  PARSER_LIST_END =      ')',
  PARSER_COMMENT_BEGIN = '[',
  PARSER_COMMENT_END   = ']',
  PARSER_STRING        = 256,
} ParserToken;
#define PARSER_SYMBOLS       " =(){}[]"
#define PARSER_SKIP_SYMBOLS  "[]"

/*
====================================================================
Входная строка преобразуется в древовидную структуру PData.
Имя идентифицирует эту запись, и поиск выполняется по токену.
для при чтении этой записи.
Устанавливаются либо «значения», либо «записи».
Если 'entry' не равно NULL, PData является группой и 'записями'
содержит указатели на другие группы или списки.
Если 'values' не равен NULL, PData представляет собой список, а 'values' содержит
список строк значений, связанных с «именем».
====================================================================
*/
typedef struct PData {
    char *name;
    List *values;
    List *entries;
    struct CommonTreeData *ctd;
    int lineno:24;	/* номер строки, из которой была проанализирована эта запись */
} PData;

/*
====================================================================
Эта функция разбивает строку на токены, используя символы
находится в символах как точки останова. Если первый символ - все
пробелы используются как точки останова, но НЕ добавляются как токен
(таким образом удален из строки).
====================================================================
*/
List* parser_split_string( const char *string, const char *symbols );
/*
====================================================================
Это облегченная версия parser_split_string, которая проверяет наличие
только один символ и не добавляет эти символы клея в
список. Это примерно на 2% быстрее. Вау.
====================================================================
*/
List *parser_explode_string( const char *string, char c );

/*
====================================================================
Эта функция считывает файл целиком и преобразует его в
Структура дерева PData. При возникновении ошибки возвращается NULL и
parser_error установлен. tree_name - это имя дерева PData.
====================================================================
*/
PData* parser_read_file( const char *tree_name, const char *fname );

/*
====================================================================
Эта функция освобождает древовидную структуру PData.
====================================================================
*/
void parser_free( PData **pdata );

/*
====================================================================
Эта функция создает новую структуру PData, вставляет ее в родительскую,
и возвращает его.
Не получает права собственности на «имя».
Владеет «списком».
====================================================================
*/
PData *parser_insert_new_pdata( PData *parent, const char *name, List *values );

/*
====================================================================
Возвращает имя файла, из которого был произведен синтаксический анализ этого узла.
====================================================================
*/
const char *parser_get_filename( PData *pd );

/*
====================================================================
Возвращает номер строки, из которой был произведен синтаксический анализ этого узла.
====================================================================
*/
int parser_get_linenumber( PData *pd );

/*
====================================================================
Функции для доступа к дереву PData.
'name' - это проход в дереве 'pd', где поддеревья разделяются
by '/' (e.g.: name = 'config/graphics/animations')
parser_get_pdata   : получить запись pdata, связанную с 'name'
parser_get_entries : получить список поддеревьев (структур PData) в 'name'
parser_get_values  : получить список значений 'name'
parser_get_value   : получить одно значение из списка значений 'name'
parser_get_int     : получить первое значение 'name', преобразованное в целое число
parser_get_double  : получить первое значение 'name', преобразованное в double
parser_get_string  : получить первое значение 'name' _duplicated_
Если возникает ошибка, устанавливается значение NULL, возвращается False и
parse_error установлен.
====================================================================
*/
int parser_get_pdata  ( PData *pd, const char *name, PData  **result );
int parser_get_entries( PData *pd, const char *name, List   **result );
int parser_get_values ( PData *pd, const char *name, List   **result );
int parser_get_value  ( PData *pd, const char *name, char   **result, int index );
int parser_get_int    ( PData *pd, const char *name, int     *result );
int parser_get_double ( PData *pd, const char *name, double  *result );
int parser_get_string ( PData *pd, const char *name, char   **result );

/*
====================================================================
Получить первое значение 'name', переведенное на текущий язык в
контекст данного домена и вернуть его дублированным_.
====================================================================
*/
int parser_get_localized_string ( PData *pd, const char *name, const char *domain, char **result );

/*
====================================================================
Возвращает, если произошла ошибка парсера
====================================================================
*/
int parser_is_error(void);

/*
====================================================================
Если произошла ошибка, вы можете запросить сообщение с помощью этой функции.
====================================================================
*/
char* parser_get_error( void );

#endif
