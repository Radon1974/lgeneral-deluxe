/***************************************************************************
                          lgeneral.h  -  description
                             -------------------
    begin                : Sat Mar 16 2002
    copyright            : (C) 2001 by Michael Speck
    email                : kulkanie@gmx.net
 ***************************************************************************/
/***************************************************************************
                     Modifications by LGD team 2012+.
 ***************************************************************************/
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

#ifndef __UNIT_LIB_H
#define __UNIT_LIB_H

/*
====================================================================
Флаги юнита.
====================================================================
*/
enum {
    SWIMMING       = ( 1L << 1 ),   /* судно */
    DIVING         = ( 1L << 2 ),   /* подводная лодка */
    FLYING         = ( 1L << 3 ),   /* самолет */
    PARACHUTE      = ( 1L << 4 ),   /* может высадиться где угодно */
    TRANSPORTER    = ( 1L << 7 ),   /* перевозчик */
    RECON          = ( 1L << 8 ),   /* несколько движений за раунд */
    ARTILLERY      = ( 1L << 9 ),   /* оборонительный огонь */
    INTERCEPTOR    = ( 1L << 10 ),  /* защищает близких бомбардировщиков */
    AIR_DEFENSE    = ( 1L << 11 ),  /* оборонительный огонь */
    BRIDGE_ENG     = ( 1L << 12 ),  /* строит мост через реки */
    INFANTRY       = ( 1L << 13 ),  /* пехота */
    AIR_TRSP_OK    = ( 1L << 14 ),  /* может использовать воздушный транспортер */
    DESTROYER      = ( 1L << 15 ),  /* может атаковать подводные лодки */
    IGNORE_ENTR    = ( 1L << 16 ),  /* игнорировать закрепление цели */
    CARRIER        = ( 1L << 17 ),  /* авианосец */
    CARRIER_OK     = ( 1L << 18 ),  /* может поставить на авианосец */
    BOMBER         = ( 1L << 19 ),  /* получает защиту от перехватчиков */
    ATTACK_FIRST   = ( 1L << 20 ),  /* юнит теряет атаку при движении */
    LOW_ENTR_RATE  = ( 1L << 21 ),  /* ставка окопания 1 */
    TANK           = ( 1L << 22 ),  /* это танк */
    ANTI_TANK      = ( 1L << 23 ),  /* противотанковый (бонус против танков) */
    SUPPR_FIRE     = ( 1L << 24 ),  /* юнит в первую очередь вызывает подавление при стрельбе */
    TURN_SUPPR     = ( 1L << 25 ),  /* вызывает длительное подавление */
    JET            = ( 1L << 26 ),  /* самолет - реактивный самолет */
    GROUND_TRSP_OK = ( 1L << 27 ),  /* может иметь транспортер (для покупки) */
    BUNKER_KILLER  = ( 1L << 5 ),   /* +4 к атаке против юнитов форта */
    TORPEDO_BOMBER = ( 1L << 6 ),   /* может атаковать военно-морские юниты из соседнего гекса */
    RADAR          = ( 1L << 28 ),  /* игнорировать большинство ограничений, вызванных ночными поворотами */
    NIGHT_OPTICS   = ( 1L << 29 ),  /* игнорировать снижение обнаружения в ночных поворотах и ​​получить инициативу по нерадарным юнитам */
    BANZAI         = ( 1L << 30 ),  /* юнит может получить бонус атаки в обмен на силу защиты */
    GUIDE          = ( 1L << 31 ),  /* этот и соседние отряды игнорируют затраты на перемещение для джунглей, леса и бамбука */
    RANGER         = ( 1L << 1 ),   /* невосприимчив к «Rugged Defense» и имеют 20% бонус к их способности применять «Rugged Defense» */
    FEARLESS       = ( 1L << 2 ),   /* юнит никогда не отступать. Если происходит отступление, вместо этого теряется +1 к силе. */
    SONAR          = ( 1L << 3 ),   /* увеличивает шанс обнаружить подводные лодки, идущие под водой, на 20% */
    KAMIKAZI       = ( 1L << 4 ),   /* в конце любой атаки юнит уничтожается */
    GUARD          = ( 1L << 5 ),   /* юнит с большей вероятностью заставит юнита отступить */
};

/*
====================================================================
Типы целей, типы движения, классы юнитов
Они могут быть загружены, только если unit_lib_main_loaded имеет значение False.
====================================================================
*/
typedef struct {
    char *id;
    char *name;
} Trgt_Type;
typedef struct {
    char *id;
    char *name;
#ifdef WITH_SOUND
    Wav *wav_move;
#endif
} Mov_Type;
typedef struct {
    char *id;
    char *name;
#define UC_PT_NONE   0
#define UC_PT_NORMAL 1
#define UC_PT_TRSP   2
    int  purchase;
} Unit_Class;

/*
====================================================================
Иконки информации на тайлах карты юнитов (сила, движение, атака ...)
====================================================================
*/
typedef struct {
    SDL_Surface *str;
    int str_w, str_h;
    SDL_Surface *atk;
    SDL_Surface *mov;
    SDL_Surface *guard;
} Unit_Info_Icons;
/*
====================================================================
Стили значков объектов.
  SINGLE:   юнит смотрит влево и зеркально выглядит вправо
  FIXED:    юнит имеет фиксированное направление обзора
  ALL_DIRS: юнит имеет значок (расположенный по горизонтали) для каждого
            направление взгляда.
====================================================================
*/
enum {
    UNIT_ICON_SINGLE = 0,
    UNIT_ICON_FIXED,
    UNIT_ICON_ALL_DIRS
};

/*
====================================================================
Поскольку мы разрешаем объединение юнитов, должна быть возможность изменять неглубокий
копия Unit_Lib_Entry (id, имя, значки, звуки сохраняются). Этот
означает, что атаковать как указатель довольно плохо. Итак, мы ограничиваем это
массив до максимального количества целевых типов.
====================================================================
*/
enum { TARGET_TYPE_LIMIT = 10 };

/*
====================================================================
Запись в библиотеке модуля.
====================================================================
*/
typedef struct {
    char *id;       /* идентификация этой записи */
    char *name;     /* имя */
    int nation;     /* нация */
    int class;      /* класс юнита */
    int trgt_type;  /* тип цели */
    int ini;        /* инициатива */
    int mov;        /* движение */
    int mov_type;   /* тип движения */
    int spt;        /* пятнистость */
    int rng;        /* диапазон атаки */
    int atk_count;  /* количество атак за ход */
    int atks[TARGET_TYPE_LIMIT]; /* значения атаки (количество определяется глобальным target_type_count) */
    int def_grnd;   /* наземная оборона (нелетные части) */
    int def_air;    /* ПВО */
    int def_cls;    /* ближняя защита (пехота против непехоты) */
    int entr_rate;  /* по умолчанию 2, если установлен флаг LOW_ENTR_RATE, то только 1 и
                       если установлена ​​ПЕХОТА, это 3, это изменяет прочную защиту.
                       шанс */
    int ammo;       /* максимальный боезапас */
    int fuel;       /* макс. топливо (0, если не используется) */
    SDL_Surface *icon;      /* тактический значок */
    SDL_Surface *icon_tiny; /* вдвое меньше; используется для отображения воздушной и наземной части на одной клетке */
    int icon_type;          /* либо single, либо all_dirs */
    int icon_w, icon_h;     /* размер одного значка */
    int icon_tiny_w, icon_tiny_h; /* размер одного значка */
    int flags[2];
    int start_year, start_month, last_year; /* время использования */
    int cost; /* стоимость покупки в престижных баллах */

#ifdef WITH_SOUND
    int wav_alloc;          /* если этот флаг установлен, wav_move должен быть освобожден, иначе это указатель */
    Wav *wav_move;  /* указатель на звук по умолчанию для класса юнита, если wav_alloc не установлен */
#endif
    int eval_score; /* от 0 до 1000, что указывает на стоимость юнита относительно
                       лучший */
} __attribute((packed)) Unit_Lib_Entry;


/*
====================================================================
Загрузите библиотеку модулей. Если UNIT_LIB_MAIN передается target_types,
Также будут загружены классы mov_types и unit (может произойти только один раз).
Если UNIT_LIB_BASE_DATA передается только target_types,
mov_types и юнит-классы будут загружены (может произойти только один раз)
====================================================================
*/
enum {
    UNIT_LIB_ADD = 0,
    UNIT_LIB_BASE_DATA,
    UNIT_LIB_MAIN
};
int unit_lib_load( char *fname, int main );

/*
====================================================================
Удалить библиотеку юнитов.
====================================================================
*/
void unit_lib_delete( void );

/*
====================================================================
Удалить запись библиотеки юнитов.
====================================================================
*/
void unit_lib_delete_entry( void *ptr );

/*
====================================================================
Найдите запись в библиотеке юнитов по строке идентификатора.
====================================================================
*/
Unit_Lib_Entry* unit_lib_find( char *id );

/*
====================================================================
Найдите значки юнитов на листе изображений.
====================================================================
*/
void lib_entry_set_icons( int icon_id, Unit_Lib_Entry *unit );

/*
====================================================================
Оцените юнит. Эта оценка станет относительной, тогда как
лучший рейтинг - 1000. Каждый рабочий регион
земля / море / воздух будет иметь свою собственную ссылку.
Эта оценка специфична для PG.
====================================================================
*/
void unit_lib_eval_unit( Unit_Lib_Entry *unit );

void adjust_fixed_icon_orientation();

/*
====================================================================
Относительная оценка юнита
====================================================================
*/
void relative_evaluate_units();

/*
====================================================================
Проверьте, есть ли у юнита определенные способности.
====================================================================
*/
int unit_has_flag( Unit_Lib_Entry *unit, char *flag );

/*
====================================================================
Получить идентификатор (номер) типа движения
====================================================================
*/
int movement_type_get_index( char *movement_type );

#endif
